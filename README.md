# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере
работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и
условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удалённо включать/выключать отопление в своих домах.
- Система поддерживает автоматическое управление отоплением.
- Включение/выключение через синхронные запросы от сервера к реле отопления.

**Мониторинг температуры:**

- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
- Система поддерживает получение данные о температуре с датчиков, установленных в домах.

### 2. Анализ архитектуры монолитного приложения

- Язык программирования: Go
- База данных: PostgreSQL
- Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в
  рамках одного приложения.
- Взаимодействие: Синхронное, запросы обрабатываются последовательно.
- Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
- Развертывание: Требует остановки всего приложения.

Сильные стороны:

- Простота развертывания (один бинарник).
- Надёжность синхронной коммуникации.
- Централизованное управление данными (PostgreSQL).

Слабые стороны:

- Низкая масштабируемость: нельзя масштабировать отдельные компоненты.
- Высокая связанность: добавление новых функций сложно.
- Зависимость от синхронных вызовов: риск задержек при росте нагрузки.

### 3. Определение доменов и границы контекстов

Домен: Управление устройствами (Device Management)
   Ответственность:
      Регистрация, подключение и управление устройствами (отопление, свет, ворота, партнерские устройства).
      Поддержка стандартных протоколов (MQTT, HTTP, Zigbee).
      Контроль состояния устройств (включено/выключено, настройки).
   Границы контекста:
      Взаимодействие с физическими устройствами через API или брокер сообщений.
      Хранение метаданных устройств (ID, тип, статус, местоположение).
   Не входит в контекст:
      Обработка телеметрии (это отдельный домен).
      Создание пользовательских сценариев (домен автоматизации).

Домен: Телеметрия и мониторинг (Telemetry & Monitoring)
   Ответственность:
      Сбор данных с устройств (температура, энергопотребление, статус).
      Хранение и анализ временных рядов.
      Визуализация данных для пользователей.
   Границы контекста:
      Прием событий через брокер сообщений (Kafka/RabbitMQ). 
      Интеграция с базами данных временных рядов (InfluxDB).
   Не входит в контекст:
      Управление устройствами (только получение данных).
      Автоматизация действий на основе данных.

Домен: Автоматизация и сценарии (Automation & Rules)
   Ответственность:
      Создание пользовательских правил («если температура < 20°C, включить отопление»). 
      Обработка событий в реальном времени.
      Отправка команд устройствам через брокер сообщений.
   Границы контекста:
      Подписка на события телеметрии.
      Интеграция с сервисом управления устройствами.
   Не входит в контекст:
      Хранение телеметрии.
      Физическое управление устройствами.

Домен: Самообслуживание и портал (Self-Service Portal)
   Ответственность:
      Веб-интерфейс для подключения устройств и настройки сценариев.
      Управление пользовательскими аккаунтами (регистрация, роли).
   Границы контекста:
      Интеграция с сервисом аутентификации (OAuth2/JWT).
      Взаимодействие с другими сервисами через API Gateway.
   Не входит в контекст:
      Непосредственное управление устройствами.
      Обработка телеметрии.

Домен: Аутентификация и авторизация (Auth & Security)
   Ответственность:
      Управление пользователями, ролями и правами.
      Обеспечение безопасности API.
   Границы контекста:
      Выдача и валидация токенов (JWT).
      Интеграция с внешними провайдерами (Google, Apple).
   Не входит в контекст:
      Бизнес-логика других доменов.

Домен: Уведомления (Notifications)
   Ответственность:
      Отправка оповещений (email, SMS, push) о критических событиях.
      Интеграция с внешними сервисами (SendGrid, Twilio).
   Границы контекста:
      Подписка на события из доменов автоматизации и телеметрии.
      Очередь задач для асинхронной отправки.
   Не входит в контекст:
      Определение правил для уведомлений (это домен автоматизации).

### **4. Проблемы монолитного решения**

Низкая масштабируемость
   Проблема: Монолит сложно масштабировать горизонтально. При увеличении нагрузки (например, рост числа пользователей или устройств)
      приходится масштабировать всё приложение целиком, а не отдельные компоненты.
   Последствия: Высокие затраты на ресурсы, неэффективное использование инфраструктуры. Например, сервис телеметрии может требовать
      больше вычислительных мощностей, чем управление устройствами, но в монолите их нельзя масштабировать независимо.

Сложность внедрения новых функций
   Проблема: Все компоненты тесно связаны. Добавление поддержки новых устройств (свет, ворота) или интеграция с партнерами
      требует изменения кода монолита, что повышает риск ошибок и замедляет разработку.
   Последствия: Невозможность быстро адаптироваться к требованиям рынка. Например, подключение новых протоколов (MQTT, Zigbee)
      может нарушить работу существующего функционала.

Ограниченная отказоустойчивость
   Проблема: Сбой в одном компоненте (например, при обработке телеметрии) может привести к падению всей системы. 
   Последствия: Низкая доступность сервиса, что критично для SaaS-платформы, где пользователи ожидают круглосуточного доступа.

Сложности с развертыванием
   Проблема: Любое обновление требует полной остановки приложения.
   Последствия: Простой сервиса во время деплоя.
                Невозможность реализовать непрерывную доставку (CI/CD), что критично для SaaS.

Технологические ограничения
   Проблема: Монолит использует единый стек (Go + PostgreSQL), который не оптимален для всех задач. 
         Например: PostgreSQL не подходит для хранения временных рядов (телеметрия).
   Последствия: Низкая производительность и сложности при обработке больших объемов данных.

### 5. Визуализация контекста системы — диаграмма С4

```markdown
[Диаграмма контекста](https://github.com/SergeiLisovoi22/architecture-warmhouse-main/blob/warmhouse/docs/docs/warmhouse/context.md)
```

Чтобы добавить ссылку в файл Readme.md, нужно использовать синтаксис Markdown. Это делают так:

```markdown
[Текст ссылки](URL)
```

Замените `Текст ссылки` текстом, который хотите использовать для ссылки. Вместо `URL` вставьте адрес, на который должна
вести ссылка. Например:

```markdown
[Посетите Яндекс](https://ya.ru/)
```

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся
микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите
диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров](https://github.com/SergeiLisovoi22/architecture-warmhouse-main/blob/warmhouse/docs/docs/warmhouse/container.md)

**Диаграмма компонентов (Components)**

[Диаграмма компонентов](https://github.com/SergeiLisovoi22/architecture-warmhouse-main/blob/warmhouse/docs/docs/warmhouse/component.md)

**Диаграмма кода (Code)**

[Диаграмма кода](https://github.com/SergeiLisovoi22/architecture-warmhouse-main/blob/warmhouse/docs/docs/warmhouse/code.md)

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.

# Задание 4. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы.
Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе
   /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска
   postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


